#!/usr/bin/env zsh
programname=$0:t
help() {
    cat >&1 <<END
WebMaster â€” wishmaster for WebM encoding: magic button with additional controls
Usage: $programname [file1 options] file1 [[file2 options] file2] ...
Options:
    .		- use last specified file
    -8		- use VP8 video codec
    -9		- use VP9 video codec (default)
    -s time	- start of needle fragment in source video
        .: detect black frames and cut them (default)
        time values will be reset to 0 at each file
    -t length	- duration of fragment
    -T time	- end of fragment (from beginning of file)
	must be specified after -s
    -a value	- audio option:
	0-9: libvorbis quality
	>=10: opus bitrate, kbit/s (default: 64)
	.: copy audio
	n: disable audio
    -f		- owerwrite files
	(othervise conversion with existing results will be skipped)
    -w width	- scale destination video to given width
	. - don't scale (default)
    -b		- use "best" VP8/VP9 quality setting
    -C value	- cpu-used VP8/VP9 setting (quality: 0..4, 0 - better, default: 1)
    -c crf	- specify constant rate factor (default: 16)
    -m qp	- miniumal quantizer scale, qmin (default: 8)
    -M qp	- qmax (default: 60)
    -B bitrate  - specify video bitrate, bps (suffixes: k, m, g)
	.: calculate bitrate from file size (default)
    -p value	- add preview:
	existing file - picture (not implemented yet)
	time - copy frame of video
    -n filename - output filename (.webm will be added)
    -F size     - result size, kilobytes (default: 6144)
    -S filename - render subtitles (. to use subs from container)
    -A value	- audio filters
    -V value	- video filters
Options of prior files will be used as defaults for next.
Exceptions: filename (-n), time options (-s -t -T), preview (-p).
END
    exit 1
}
log() {
    echo -e "[i] $@"
}
time_to_seconds() {
    [[ $1 =~ ^((([0-9]+):)?([0-9]+):)?([0-9.]+)$ ]]
    local result=$((match[3]*3600 + match[4]*60 + match[5]))
    [[ -n $2 ]] && (($2=result)) || echo $result
}
perform() {
    echo $@
    $@
}
# defaults
width=.
fsize=6144
best=0
audio=64
force=0
vp9=1
crf=16
cpuused=1
qmin=8
qmax=60
force_bitrate=.
[[ -n $FFMPEG ]] || FFMPEG=(ffmpeg -hide_banner -v warning -stats)

# config file
for f in $0.rc ~/.${programname}rc; [[ -f $f ]] && source  $f
unset f

[[ -z $1 ]] && help
set -e

while [[ ! -z $1 ]]
do
    unset of
    start=.
    unset length
    vfilters=()
    afilters=()
    iopts=()  # ffmpeg input options
    vopts=()  # video output options
    aopts=()  # audio output options
    opts=()  # general output options
    OPTIND=1
    while getopts "89a:fbC:c:m:M:B:w:s:t:T:n:S:hF:p:A:V:" o
    do
        case $o in
	    8)  vp9=0;;
	    9)  vp9=1;;
	    a)  audio=$OPTARG;;
            f)  force=1;;
            w)  width=$OPTARG;;
            s)  [[ $OPTARG == . ]] && start=$OPTARG || time_to_seconds $OPTARG start;;
            t)  time_to_seconds $OPTARG length;;
	    T)  length=$(($(time_to_seconds $OPTARG) - start));;
            b)  best=1;;
	    C)  cpuused=$OPTARG;;
	    c)	crf=$OPTARG;;
	    m)  qmin=$OPTARG;;
	    M)  qmax=$OPTARG;;
	    B)	force_bitrate=$OPTARG;;
	    p)	preview=$OPTARG;;
	    n)  of="${OPTARG%.webm}.webm";;
	    S)  subs=$OPTARG;;
	    F)  fsize=$OPTARG;;
	    A)	custom_afilters=$OPTARG;;
	    V)	custom_vfilters=$OPTARG;;
	    h|?)  help;;
	esac
    done
    shift $((OPTIND - 1))
    [[ $1 == . ]] || f=$1
    [[ -z $f ]] && help

    [[ -z $of ]] && of="${f:t:r}.webm"  # strip path and extension
    [[ $of == $f ]] && of=${f/webm/converted.webm}
    tmpdir="$of.tmp"
    if ! ((force)) && [[ -f $of ]]
    then
        shift
        continue
    fi
    mkdir -p $tmpdir

    if ((vp9))
    then
	vopts+=(-c:v libvpx-vp9 -strict -2 -auto-alt-ref 1 -lag-in-frames 25)
    else
	vopts=(-c:v libvpx -auto-alt-ref 1 -lag-in-frames 16)
    fi
    if [[ $audio == "." ]]
	then aopts=(-c:a copy)
    elif (($audio >= 10))
	then aopts=(-c:a libopus -b:a "${audio}k")
    elif [[ $audio == "n" ]]
	then aopts=(-an)
    else
	aopts=(-q:a $audio)
    fi

    [[ $start == . ]] && start=$(
        ffmpeg -i $f -vframes 200 -vf blackdetect=d=0.01 -f null -y /dev/null 2>&1 \
        | awk -F'[: ]' '/black_start:0 /{print $9}')

    vfilters=( )
    afilters=( )
    [[ $width != . ]] && vfilters+=("scale=${width}:trunc(${width}/dar/2)*2")
    [[ -n $start ]] && iopts+=(-ss $start)
    if [[ -n $subs ]]
    then
	[[ $subs == . ]] && subs=$f
	[[ $subs =~ ass$ ]] \
            && subs="ass='${subs//'\'/'\\'}'" \
            || subs="subtitles='${subs//'\'/'\\'}'"
        (($start)) \
            && vfilters+=( setpts=PTS+$start/TB $subs setpts=PTS-STARTPTS ) \
            || vfilters+=( $subs )
    fi
    vfilters+=( $custom_vfilters )
    afilters+=( $custom_afilters )
    af="$tmpdir/audio.webm"
    vf="$tmpdir/video.webm"
    time_to_seconds "$(ffprobe $f 2>&1|sed -n 's/.*Duration: \([^,]\+\),.*/\1/p')" filelength
    if [[ -z $length ]]
    then
	if [[ -z $start ]]
	then
	    length=$filelength
	else
	    ((length = filelength - start))
	fi
    fi
    opts+=(-t $length)
    ((${#afilters})) && aopts+=(-af ${(j:,:)afilters})
    ((${#vfilters})) && vopts+=(-vf ${(j:,:)vfilters})
    (($best)) && vopts+=(-quality best)
    time_start=$SECONDS
    if [[ $audio == "n" ]]
    then
        ((vbitrate = fsize * 8 / length))
        unset af
    else
	if [[ ! -f $af ]] || ((force))
        then
            log "Encoding audio"
	    perform $FFMPEG $iopts -i $f \
		-vn -map 0:a:0 $opts $aopts -strict -2 -y $af
        fi
	((vbitrate = (fsize - $(stat -c%s $af) / 1024) * 8 / length))
    fi
    echo -e "\n"
    log "Calculated video bitrate: ${vbitrate}"
    if [[ $force_bitrate != '.' ]]
    then
	vbitrate=$force_bitrate
	log "Forced video bitrate: ${vbitrate}"
    fi
    time_start1pass=$SECONDS
    log "Examining video"
    [[ -f "$tmpdir/2pass-0.log" ]] && ! ((force)) || 
	perform $FFMPEG $iopts -i $f \
	    -an -map 0:v:0 $opts $vopts -cpu-used $cpuused -pass 1 -passlogfile "$tmpdir/2pass" -f null - || break
    echo
    echo -e "\n"
    time_start2pass=$SECONDS
    log "Encoding video"
    [[ -f $vf ]] && ! ((force)) ||
	perform $FFMPEG $iopts -i $f \
	    -an -map 0:v:0 $opts $vopts \
	    -b:v ${vbitrate}K -cpu-used $cpuused -crf $crf -qmin $qmin -qmax $qmax \
	    -pass 2 -passlogfile "$tmpdir/2pass" -y $vf || break
    #ffmpeg -i $vf ${af+-i} $af -c copy -strict -2 -y $of
    echo -e "\n"
    perform mkvmerge -q $vf $af -o $of || [[ -f $of ]]  # mkvmerge doesn't return succeful exit code,
						 # so checking for result existence instead
    if [[ ! -z $preview ]]
    then
	pf="$tmpdir/1stframe.webm"
	if [[ -f $preview ]]
	then ipreview=(-i $preview)
	    echo "[SKIP] -p $preview: option not implemented yet"
	else
	    ipreview=(-ss $preview -i $of)
	    perform $FFMPEG $ipreview -b:v 5M -crf 20 -vframes 1 -af volume=0 $vopts $aopts -strict -2 $pf
	#fi
	    perform mkvmerge -q $pf + $of -o $of.pr.webm || :
	    [ -f $of.pr.webm ] && mv $of.pr.webm $of
	fi
	#$FFMPEG $ipreview -filter_complex 'anullsrc [a]' -map 0:v -map '[a]' -vframes 1 $aopts 
    fi
    ofsize="$(stat -c %s $of)"  # result file size
    log "$of encoded. Size: $((ofsize/1024))KB, time (total/audio/1pass/2pass): $((
	SECONDS - time_start))/$((time_start1pass - time_start))/$((
	time_start2pass - time_start1pass))/$((SECONDS - time_start2pass))s"
    if ((ofsize > fsize * 1024))
    then
	log "$of is too big, leaving temporary files"
    else
	rm -r $tmpdir
    fi
    shift
done
